name: Slack Notifications (Issues/PRs/Releases)

on:
  workflow_dispatch:
    inputs:
      test_message:
        description: 'Send a test message to Slack'
        required: false
        default: 'Manual test from workflow_dispatch'
  issues:
    types: [opened, edited, closed, reopened]
  issue_comment:
    types: [created]
  pull_request:
    types: [opened, ready_for_review, review_requested, closed, reopened, converted_to_draft, synchronize]
  release:
    types: [published]

permissions:
  contents: read

jobs:
  notify:
    runs-on: ubuntu-latest
    
    env:
      CH_ISSUES:   ${{ secrets.SLACK_CH_ISSUES }}
      CH_PRS:      ${{ secrets.SLACK_CH_PRS }}
      SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
      
    steps:
      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq
        
      - name: Build Slack payload (Block Kit)
        id: payload
        env:
          EVENT_PATH: ${{ github.event_path }}
          GITHUB_RUN_URL: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
          TEST_MESSAGE: ${{ inputs.test_message }}
          RUN_ID: ${{ github.run_id }}
        run: |
          set -euo pipefail
          # 공통 컨텍스트 추출
          DATE=$(date +%Y-%m-%d)
          REPO="$(jq -r '.repository.full_name' "$EVENT_PATH")"
          ACTOR="${GITHUB_ACTOR}"
          EVENT_NAME="${GITHUB_EVENT_NAME}"
          ACTION="$(jq -r '.action // empty' "$EVENT_PATH")"

          # URL/제목/본문/번호/머지여부 등 추출
          URL=$(jq -r '.issue.html_url // .pull_request.html_url // .release.html_url // .comment.html_url // .repository.html_url' "$EVENT_PATH")
          NUMBER=$(jq -r '.issue.number // .pull_request.number // empty' "$EVENT_PATH")
          TITLE_RAW=$(jq -r '.issue.title // .pull_request.title // .release.name // empty' "$EVENT_PATH")
          BODY_RAW=$(jq -r '.issue.body // .pull_request.body // .release.body // .comment.body // empty' "$EVENT_PATH")
          BODY_TRUNC=$(printf "%s" "$BODY_RAW" | head -c 500)

          MERGED=$(jq -r '.pull_request.merged // false' "$EVENT_PATH")

          # 이벤트 → 채널 라우팅
          CHANNEL=""
          case "${EVENT_NAME}" in
            issues|issue_comment) CHANNEL="${CH_ISSUES}";;
            pull_request)         CHANNEL="${CH_PRS}";;
          esac
          
          # 이벤트별 타이틀/이모지/색상
          TITLE=""
          COLOR="#dddddd"
          case "${EVENT_NAME}/${ACTION}" in
            issues/opened)              TITLE="💡 이슈 열림" ; COLOR="#36a64f" ;;
            issues/closed)              TITLE="✅ 이슈 닫힘" ; COLOR="#aaaaaa" ;;
            issues/reopened)            TITLE="🔄 이슈 다시 열림" ; COLOR="#e3b341" ;;
            pull_request/opened)        TITLE="📣 풀 리퀘스트 요청" ; COLOR="#439FE0" ;;
            pull_request/ready_for_review) TITLE="🚀 풀 리퀘스트 리뷰 준비" ; COLOR="#439FE0" ;;
            pull_request/converted_to_draft) TITLE="📝 풀 리퀘스트 초안으로 변경" ; COLOR="#aaaaaa" ;;
            pull_request/closed)
              if [ "$MERGED" = "true" ]; then
                TITLE="🎉 풀 리퀘스트 머지됨" ; COLOR="#6f42c1"
              else
                TITLE="⛔️ 풀 리퀘스트 취소" ; COLOR="#aaaaaa"
              fi
              ;;
            pull_request/synchronize)   TITLE="🔄 풀 리퀘스트 업데이트" ; COLOR="#439FE0" ;;
            release/published)          TITLE="🏷️ 릴리즈 배포" ; COLOR="#2eb67d" ;;
            issue_comment/created)      TITLE="💬 새로운 댓글" ; COLOR="#4a154b" ;;
            */)
              # workflow_dispatch 등
              TITLE="ℹ️ GitHub notification"
              ;;
            *)
              TITLE="ℹ️ ${EVENT_NAME} (${ACTION})"
              ;;
          esac

          # 수동 실행 시 테스트 메시지 지원
          if [ "${EVENT_NAME}" = "workflow_dispatch" ]; then
            BODY_TRUNC="${TEST_MESSAGE}"
            URL="https://github.com/${{ github.repository }}"
          fi

          # 본문 없으면 대체문구
          if [ -z "${BODY_TRUNC}" ]; then
            BODY_TRUNC="(no description)"
          fi

          # ── GitHub MD → Slack mrkdwn 변환 ──
          BODY_SLACK="$BODY_TRUNC"
          
          # 1) 체크리스트: - [x] / - [ ]  → • :white_check_mark: / • :white_large_square:
          BODY_SLACK=$(printf "%s" "$BODY_SLACK" | sed -E 's/^[[:space:]]*[-*][[:space:]]+\[[xX]\][[:space:]]+(.+)$/• :white_check_mark: \1/g')
          BODY_SLACK=$(printf "%s" "$BODY_SLACK" | sed -E 's/^[[:space:]]*[-*][[:space:]]+\[[[:space:]]*\][[:space:]]+(.+)$/• :white_large_square: \1/g')
          
          # 2) 일반 리스트: - item / * item → • item
          BODY_SLACK=$(printf "%s" "$BODY_SLACK" | sed -E 's/^[[:space:]]*[-*][[:space:]]+(.+)$/• \1/g')
          
          # 3) 헤딩: ### Title → *Title*  (Slack은 헤딩 문법 없음 → 볼드로 대체)
          BODY_SLACK=$(printf "%s" "$BODY_SLACK" | sed -E 's/^(#{1,6})[[:space:]]*(.+)$/*\2*/g')
          
          # 4) 링크: [text](url) → <url|text>
          BODY_SLACK=$(printf "%s" "$BODY_SLACK" | sed -E 's/\[([^\]]+)\]\((https?:[^)]+)\)/<\2|\1>/g')
          
          # 5) 볼드: **text** → *text*
          BODY_SLACK=$(printf "%s" "$BODY_SLACK" | sed -E 's/\*\*([^*]+)\*\*/*\1*/g')
          
          # 6) 이미지: ![alt](url) → <url>
          BODY_SLACK=$(printf "%s" "$BODY_SLACK" | sed -E 's/!\[[^]]*\]\((https?:[^)]+)\)/<\1>/g')
          
          # 7) 탭 → 공백
          BODY_SLACK=$(printf "%s" "$BODY_SLACK" | sed -E 's/\t/    /g')

          # 번호 표기
          NUM_FIELD=""
          if [ -n "${NUMBER}" ]; then
            NUM_FIELD="*Number:* #${NUMBER}\n"
          fi

          # Slack Block Kit payload 작성 (jq로 안전하게)
          jq -n \
          --arg channel  "$CHANNEL" \
          --arg title     "$TITLE_RAW — $TITLE" \
          --arg actor     "$ACTOR" \
          --arg eventname "$EVENT_NAME" \
          --arg action    "$ACTION" \
          --arg url       "$URL" \
          --arg repo      "$REPO" \
          --arg number    "$NUMBER" \
          --arg summary   "$TITLE_RAW" \
          --arg body      "$BODY_SLACK" \
          --arg run_url   "$GITHUB_RUN_URL" \
          --arg run_id    "$RUN_ID" \
          --arg color     "$COLOR" \
          --arg date      "$DATE" '
          def field(x): {"type":"mrkdwn","text":x};
    
          {
            channel: $channel,
            attachments: [
              {
                color: $color,
                blocks: (
                  [
                    {"type":"header","text":{"type":"plain_text","text":$title,"emoji":true}},
                    {"type":"section","text":{"type":"mrkdwn","text":"\($body)"}},
                    {"type":"section","fields":[
                      field("*작성자:*\n\($actor)"),
                      (if $number != "" then field("*번호:*\n#\($number)") else empty end)
                    ]},
                    {"type":"actions","elements":[
                      {"type":"button","text":{"type":"plain_text","text":"Open in GitHub"},"url":$url}
                    ]},
                    {"type":"context","elements":[
                      {"type":"mrkdwn","text":"Run: <\($run_url)|#\($run_id)> • \($date)"}
                    ]}
                  ] | map(select(. != null))
                )
              }
            ]
          }' > payload.json

      - name: Send to Slack via chat.postMessage (Bot Token)
        run: |
          set -euo pipefail
          RESP=$(curl -sS -X POST "https://slack.com/api/chat.postMessage" \
            -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
            -H "Content-type: application/json; charset=utf-8" \
            --data @payload.json)

          echo "$RESP" | jq .
          echo "$RESP" | jq -e '.ok == true' >/dev/null || {
            echo "Slack API error: $(echo "$RESP" | jq -r '.error // "unknown_error"')"
            exit 1
          }
